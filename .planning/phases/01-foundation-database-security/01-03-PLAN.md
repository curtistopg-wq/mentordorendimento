---
phase: 01-foundation-database-security
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/config.toml
  - supabase/migrations/20260126000000_initial_schema.sql
  - supabase/seed.sql
autonomous: true

must_haves:
  truths:
    - "All tables have RLS enabled"
    - "All tables have appropriate policies for CRUD operations"
    - "Enrollment records can track user-course access"
    - "Progress records can track lesson completion"
    - "Policy columns have indexes for performance"
  artifacts:
    - path: "supabase/migrations/20260126000000_initial_schema.sql"
      provides: "Complete database schema with RLS"
      contains: "ENABLE ROW LEVEL SECURITY"
    - path: "supabase/config.toml"
      provides: "Local Supabase configuration"
    - path: "supabase/seed.sql"
      provides: "Test data for development"
  key_links:
    - from: "supabase/migrations/*"
      to: "public.profiles"
      via: "profiles table creation"
      pattern: "CREATE TABLE public\\.profiles"
    - from: "supabase/migrations/*"
      to: "public.enrollments"
      via: "enrollments table for user-course access"
      pattern: "CREATE TABLE public\\.enrollments"
    - from: "supabase/migrations/*"
      to: "public.progress"
      via: "progress table for lesson completion"
      pattern: "CREATE TABLE public\\.progress"
---

<objective>
Initialize Supabase CLI and create database schema with RLS policies.

Purpose: Establish the secure database foundation with proper Row Level Security BEFORE any user data exists. This prevents the most common Supabase security vulnerability (83% of breaches involve RLS misconfiguration).

Output:
- Supabase CLI initialized with config.toml
- Complete database migration with all tables
- RLS enabled on ALL tables with appropriate policies
- Indexes on all columns used in RLS policies
- Seed data for development testing
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-database-security/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Supabase CLI</name>
  <files>supabase/config.toml</files>
  <action>
Initialize Supabase in the project:
```bash
npx supabase init
```

This creates the `supabase/` directory with:
- config.toml (local configuration)
- migrations/ folder (empty initially)
- seed.sql (empty initially)

Verify the supabase/ folder structure exists after running the command.

NOTE: This does NOT require Docker or a running Supabase instance yet.
Docker is only needed for `supabase start` (local development server).
For now, we're just creating the migration files.
  </action>
  <verify>
Directory `supabase/` exists.
File `supabase/config.toml` exists.
Directory `supabase/migrations/` exists.
  </verify>
  <done>
Supabase CLI initialized with supabase/ directory.
config.toml exists with default configuration.
migrations/ directory ready for schema files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database schema with RLS policies</name>
  <files>supabase/migrations/20260126000000_initial_schema.sql</files>
  <action>
Create the migration file `supabase/migrations/20260126000000_initial_schema.sql` with the complete schema.

CRITICAL RULES:
1. Enable RLS in the SAME statement block that creates each table
2. Create policies IMMEDIATELY after enabling RLS
3. Use `(SELECT auth.uid())` not `auth.uid()` for 100x+ performance
4. Create indexes on ALL columns used in RLS policies
5. Never use `FOR ALL` policies - separate SELECT, INSERT, UPDATE, DELETE

```sql
-- ============================================
-- MESTRES COURSE PLATFORM - INITIAL SCHEMA
-- ============================================
-- Created: 2026-01-26
-- Requirements: DATA-01, DATA-03, DATA-04, DATA-05
-- ============================================

-- ============================================
-- PROFILES TABLE (extends auth.users)
-- ============================================
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  full_name TEXT,
  avatar_url TEXT,
  role TEXT NOT NULL DEFAULT 'student' CHECK (role IN ('student', 'instructor', 'admin')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Profiles policies
CREATE POLICY "Users can view all profiles"
  ON public.profiles FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Users can update own profile"
  ON public.profiles FOR UPDATE
  TO authenticated
  USING ((SELECT auth.uid()) = id)
  WITH CHECK ((SELECT auth.uid()) = id);

-- Index on role for admin queries
CREATE INDEX idx_profiles_role ON public.profiles(role);

-- ============================================
-- COURSES TABLE
-- ============================================
CREATE TABLE public.courses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  description TEXT,
  thumbnail_url TEXT,
  instructor_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  is_published BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE public.courses ENABLE ROW LEVEL SECURITY;

-- Courses policies
CREATE POLICY "Anyone can view published courses"
  ON public.courses FOR SELECT
  TO authenticated, anon
  USING (is_published = true);

CREATE POLICY "Instructors can view own courses"
  ON public.courses FOR SELECT
  TO authenticated
  USING ((SELECT auth.uid()) = instructor_id);

CREATE POLICY "Instructors can insert own courses"
  ON public.courses FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT auth.uid()) = instructor_id);

CREATE POLICY "Instructors can update own courses"
  ON public.courses FOR UPDATE
  TO authenticated
  USING ((SELECT auth.uid()) = instructor_id)
  WITH CHECK ((SELECT auth.uid()) = instructor_id);

CREATE POLICY "Instructors can delete own courses"
  ON public.courses FOR DELETE
  TO authenticated
  USING ((SELECT auth.uid()) = instructor_id);

-- Indexes for RLS policy columns
CREATE INDEX idx_courses_instructor_id ON public.courses(instructor_id);
CREATE INDEX idx_courses_is_published ON public.courses(is_published);
CREATE INDEX idx_courses_slug ON public.courses(slug);

-- ============================================
-- MODULES TABLE (course sections)
-- ============================================
CREATE TABLE public.modules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  course_id UUID NOT NULL REFERENCES public.courses(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  position INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE public.modules ENABLE ROW LEVEL SECURITY;

-- Modules policies
CREATE POLICY "Anyone can view modules of published courses"
  ON public.modules FOR SELECT
  TO authenticated, anon
  USING (
    EXISTS (
      SELECT 1 FROM public.courses
      WHERE courses.id = modules.course_id
      AND courses.is_published = true
    )
  );

CREATE POLICY "Instructors can manage modules of own courses"
  ON public.modules FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.courses
      WHERE courses.id = modules.course_id
      AND courses.instructor_id = (SELECT auth.uid())
    )
  );

-- Indexes for modules
CREATE INDEX idx_modules_course_id ON public.modules(course_id);
CREATE INDEX idx_modules_position ON public.modules(course_id, position);

-- ============================================
-- LESSONS TABLE
-- ============================================
CREATE TABLE public.lessons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  module_id UUID NOT NULL REFERENCES public.modules(id) ON DELETE CASCADE,
  course_id UUID NOT NULL REFERENCES public.courses(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  video_path TEXT,
  duration_seconds INTEGER,
  position INTEGER NOT NULL DEFAULT 0,
  is_free BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE public.lessons ENABLE ROW LEVEL SECURITY;

-- Lessons policies
CREATE POLICY "Anyone can view lesson metadata of published courses"
  ON public.lessons FOR SELECT
  TO authenticated, anon
  USING (
    EXISTS (
      SELECT 1 FROM public.courses
      WHERE courses.id = lessons.course_id
      AND courses.is_published = true
    )
  );

CREATE POLICY "Instructors can manage lessons of own courses"
  ON public.lessons FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.courses
      WHERE courses.id = lessons.course_id
      AND courses.instructor_id = (SELECT auth.uid())
    )
  );

-- Indexes for lessons
CREATE INDEX idx_lessons_module_id ON public.lessons(module_id);
CREATE INDEX idx_lessons_course_id ON public.lessons(course_id);
CREATE INDEX idx_lessons_position ON public.lessons(module_id, position);

-- ============================================
-- ENROLLMENTS TABLE (DATA-03: user-course access)
-- ============================================
CREATE TABLE public.enrollments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  course_id UUID NOT NULL REFERENCES public.courses(id) ON DELETE CASCADE,
  enrolled_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, course_id)
);

ALTER TABLE public.enrollments ENABLE ROW LEVEL SECURITY;

-- Enrollments policies
CREATE POLICY "Users can view own enrollments"
  ON public.enrollments FOR SELECT
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can enroll themselves"
  ON public.enrollments FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can unenroll themselves"
  ON public.enrollments FOR DELETE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);

-- Instructors can view enrollments for their courses
CREATE POLICY "Instructors can view course enrollments"
  ON public.enrollments FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.courses
      WHERE courses.id = enrollments.course_id
      AND courses.instructor_id = (SELECT auth.uid())
    )
  );

-- Indexes for enrollments (DATA-05: policy columns have indexes)
CREATE INDEX idx_enrollments_user_id ON public.enrollments(user_id);
CREATE INDEX idx_enrollments_course_id ON public.enrollments(course_id);

-- ============================================
-- PROGRESS TABLE (DATA-04: lesson completion)
-- ============================================
CREATE TABLE public.progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  lesson_id UUID NOT NULL REFERENCES public.lessons(id) ON DELETE CASCADE,
  video_position_seconds INTEGER NOT NULL DEFAULT 0,
  completed BOOLEAN NOT NULL DEFAULT false,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, lesson_id)
);

ALTER TABLE public.progress ENABLE ROW LEVEL SECURITY;

-- Progress policies
CREATE POLICY "Users can view own progress"
  ON public.progress FOR SELECT
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can insert own progress"
  ON public.progress FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can update own progress"
  ON public.progress FOR UPDATE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id)
  WITH CHECK ((SELECT auth.uid()) = user_id);

-- Indexes for progress (DATA-05: policy columns have indexes)
CREATE INDEX idx_progress_user_id ON public.progress(user_id);
CREATE INDEX idx_progress_lesson_id ON public.progress(lesson_id);
CREATE INDEX idx_progress_user_lesson ON public.progress(user_id, lesson_id);

-- ============================================
-- MATERIALS TABLE (downloadable resources)
-- ============================================
CREATE TABLE public.materials (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lesson_id UUID NOT NULL REFERENCES public.lessons(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  file_path TEXT NOT NULL,
  file_size_bytes INTEGER,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE public.materials ENABLE ROW LEVEL SECURITY;

-- Materials policies
CREATE POLICY "Enrolled users can view materials"
  ON public.materials FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.lessons l
      JOIN public.enrollments e ON e.course_id = l.course_id
      WHERE l.id = materials.lesson_id
      AND e.user_id = (SELECT auth.uid())
    )
    OR
    -- Free lessons materials visible to all
    EXISTS (
      SELECT 1 FROM public.lessons l
      WHERE l.id = materials.lesson_id
      AND l.is_free = true
    )
  );

CREATE POLICY "Instructors can manage materials of own courses"
  ON public.materials FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.lessons l
      JOIN public.courses c ON c.id = l.course_id
      WHERE l.id = materials.lesson_id
      AND c.instructor_id = (SELECT auth.uid())
    )
  );

-- Index for materials
CREATE INDEX idx_materials_lesson_id ON public.materials(lesson_id);

-- ============================================
-- FUNCTIONS
-- ============================================

-- Auto-create profile on signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name'),
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for auto-creating profiles
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers for updated_at
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER update_courses_updated_at
  BEFORE UPDATE ON public.courses
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER update_modules_updated_at
  BEFORE UPDATE ON public.modules
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER update_lessons_updated_at
  BEFORE UPDATE ON public.lessons
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER update_progress_updated_at
  BEFORE UPDATE ON public.progress
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

-- ============================================
-- HELPER FUNCTION: Check enrollment
-- ============================================
CREATE OR REPLACE FUNCTION public.is_enrolled(p_user_id UUID, p_course_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.enrollments
    WHERE user_id = p_user_id AND course_id = p_course_id
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- HELPER FUNCTION: Get course progress
-- ============================================
CREATE OR REPLACE FUNCTION public.get_course_progress(p_user_id UUID, p_course_id UUID)
RETURNS TABLE (
  total_lessons BIGINT,
  completed_lessons BIGINT,
  progress_percentage NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(l.id) AS total_lessons,
    COUNT(p.id) FILTER (WHERE p.completed = true) AS completed_lessons,
    CASE
      WHEN COUNT(l.id) = 0 THEN 0
      ELSE ROUND((COUNT(p.id) FILTER (WHERE p.completed = true)::NUMERIC / COUNT(l.id)::NUMERIC) * 100, 2)
    END AS progress_percentage
  FROM public.lessons l
  LEFT JOIN public.progress p ON p.lesson_id = l.id AND p.user_id = p_user_id
  WHERE l.course_id = p_course_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

This schema includes:
- profiles (user data, extends auth.users)
- courses (main content)
- modules (course sections)
- lessons (individual lessons within modules)
- enrollments (DATA-03: user-course access tracking)
- progress (DATA-04: lesson completion tracking)
- materials (downloadable resources)
- All RLS policies (DATA-01)
- All indexes on policy columns (DATA-05)
- Helper functions for common queries
  </action>
  <verify>
File exists at supabase/migrations/20260126000000_initial_schema.sql.
Grep for "ENABLE ROW LEVEL SECURITY" - should appear 7 times (one per table).
Grep for "CREATE INDEX" - should appear at least 15 times.
Grep for "(SELECT auth.uid())" - should appear in all policies (not bare auth.uid()).
  </verify>
  <done>
Migration file exists with complete schema.
All 7 tables have RLS enabled.
All tables have appropriate CRUD policies.
All policy columns have indexes.
Helper functions created for enrollment check and progress calculation.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `supabase/` directory exists with config.toml
2. `supabase/migrations/20260126000000_initial_schema.sql` exists
3. Migration file contains all 7 tables with RLS enabled
4. All policy columns have indexes
5. No bare `auth.uid()` calls (all wrapped in SELECT)
</verification>

<success_criteria>
1. Supabase CLI initialized with proper folder structure
2. Migration file contains all required tables (profiles, courses, modules, lessons, enrollments, progress, materials)
3. Every table has RLS enabled (DATA-01)
4. Enrollment table tracks user-course access (DATA-03)
5. Progress table tracks lesson completion (DATA-04)
6. All columns used in policies have indexes (DATA-05)
7. All auth.uid() calls wrapped in (SELECT auth.uid()) for performance
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-database-security/01-03-SUMMARY.md`
</output>
